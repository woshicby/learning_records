# 第六章 数字签名

## 6.1 数字签名的基本概念

### 6.1.1 数字签名基本概念

**数字签名**：类似写在纸上的传统的物理签名，使用公钥加密技术实现，用于鉴别数字信息或者签名者身份的方法。

数字签名必须保证：
①接收者能够核实发送者对文档的签名；
②发送者时候不能否认对文档的签名；
③不能伪造对文档的签名。

签名包括消息和载体两个部分。消息：签名所表示的意义。载体：签名的物理表现形式

|              | 传统签名                                                   | 数字签名                                             |
| ------------ | ---------------------------------------------------------- | ---------------------------------------------------- |
| 载体         | 签名和文件是具有共同的物理载体                             | 签名与文件是电子形式，签名与文件的物理形式和消息分开 |
| 可分割       | 物理上不可分割                                             | 电子载体是可以任意分割                               |
| 可重复使用性 | 签名与文件不可分割，不能重复使用。                         | 数字签名有可能与文件分割，被重复使用。               |
| 可复制性     | 物理上不可复制                                             | 可以任意复制的                                       |
| 安全性       | 不安全                                                     | 计算上安全                                           |
| 可否认性     | 不能否认                                                   | 不能否认                                             |
| 可伪造性     | 能被伪造                                                   | 不能被伪造                                           |
| 可验证性     | 容易被验证                                                 | 容易被自动验证                                       |
| 验证方式     | 通过与存档手迹对照来确定真伪，是主观的、模糊的、容易伪造的 | 使用密码，通过公开算法进行检验，是客观的、精确的     |

传统签名的基本特点：①能与被签的文件在物理上不可分割②签名者不能否认自己的签名③签名能被伪造④容易被验证。

数字签名是传统签名的数字化，基本要求：①能与所签文件“绑定”②签名者不能否认自己的签名③签名不能被伪造④容易被自动验证。

### 6.1.2 数字签名的构成

一个数字签名方案包括如下3个算法：

①密钥生成：产生用户的公私钥。

②签名算法：产生消息的签名。

③验证算法：验收消息的签名是否合法。

### 6.1.3 数字签名安全需求

数字签名方案为了实现安全验证，需要满足如下条件：

①必须相对容易生成该数字签名。

②必须相对容易识别和验证该数字签名。

③伪造该数字签名在计算上不可行，既包括对一个已有的数字签名构造新的信息，也包括对一个信息伪造一个数字签名。

## 6.2 RSA签名算法

### 6.2.1 RSA签名算法的密钥生成

①：选两个保密的大素数p和q，$n=p\times q,\phi(n)=(p-1)(q-1)$

②：选一整数$e,1\lt e\le\phi(n),gcd(\phi(n),e)=1$

③：计算$d,d\cdot e\equiv 1(mod\ \phi(n))$

④：以$\{e,n\}$为公钥，$\{d,n\}$为私钥

### 6.2.2 RSA签名算法的签名

设消息$m\in Z_n$，对其签名为$s\equiv m^d(mod\ n)$，即求得消息m的签名为s。

### 6.2.3 RSA签名算法的验证

接收方收到消息m和签名s后，验证$m\overset{?}{\equiv}s^e(mod\ n)$。若等式成立，则s是消息m的有效签名，反之则是无效签名。

### 6.2.4 RSA签名的正确性

$d\cdot e\equiv1(mod\ \phi(n))\Rightarrow s^e=m^{de}\equiv m^{1+k\phi(n)}\equiv m^1m^(k\phi(n))\equiv m(mod\ n)$

其中k为某个整数。

### 6.2.5 RSA签名算法的缺点

对任意$y\in Z_n$，任何人可计算$x\equiv y^e(mod\ n)$，因此任何人可伪造对随机信息x的签名。

若消息$x_1,x_2$的签名分别为$y_1,y_2$，则知道$x_1,x_2,y_1,y_2$的人可伪造消息$x_1x_2$的签名$y_1y_2$。

在RSA签名方案中，需要签名的消息$x\in Z_n$，所以每次只能对$\lfloor\log_2n\rfloor$位长的信息进行签名。签名速度慢。

解决方法：引入hash函数

### 6.2.6 RSA的安全基础

RSA签名方案的安全性规约于大数分解问题。

## 6.3 EI-Gamal签名算法

1985年。EI-Gamal提出了一个基于离散对数问题的签名方案，后来称为EI-Gamal数字签名方案。

1991年该数字签名方案的变形被美国国家标准局（NIST）确定为数字签名标准（DSS）。

### 6.3.1 EI-Gamal签名算法的密钥生成

①：选取大素数$p,q\in Z^*_p$是一个本原元。p和g公开

②：随机选取整数$x,1\le x\le p-2$，计算$y=g^x(mod\ p)$

③：公钥为y，私钥为x

### 6.3.2 EI-Gamal签名算法的签名

对于消息m，首先随机选取整数$k,1\le k\le p-2$，然后计算$\begin{cases}r=g^k(mod\ p)\\s=(h(m)-xr)k^{-1}(mod\ (p-1))\end{cases}$

则m的签名为$(r,s)$，其中$h()$为hash函数。

### 6.3.3 EI-Gamal签名算法的验证

接收方在收到信息m和签名$(r,s)$后验证$y^rr^s\overset{?}{=}g^{h(m)}(mod\ p)$。

如果等式成立，则$(r,s)$是消息m的有效签名，反之则是无效签名。

### 6.3.4 EI-Gamal签名算法的正确性
$$
\because&s=(h(m)-xr)k^{-1}(mod\ (p-1))\\
\therefore&sk+xr=h(x)(mod\ (p-1))\\
\therefore&g^{h(m)}=g^{(sk+xr)}=g^{sk}g^{xr}=y^rr^s(mod\ p)
$$
### 6.3.5 EI-Gamal签名算法的两个问题

①：用EI-Gamal方案计算一个签名时，使用的随机数k能不能泄漏？

②：若Bob用相同的k值来签名两份不同的信息，Oscar能否攻破这个体制？

## 6.4 DSS签名算法

1991年，数字签名标准（DSS）在EI-Gamal数字签名和Schnorr数字签名的基础上发展而来，被美国国家标准局（NIST）确定为数字签名标准。

### 6.4.1 DSS签名算法的密钥生成

①：设$512\le L\le1024$且L是64的倍数，选取$2^{L-1}\lt p\lt 2^L$的大素数p，其满足存在160比特的素数$q\mid p-1$

②：随机选取整数$h,g$，使得$1\lt h\lt p-1,g=h^{\frac{p-1}{q}}(mod\ p)\gt1$，p和g公开

③：随机选取整数$x,1\le x\le q-1$，计算$y=g^x(mod\ p)$

④：公钥为y，私钥为x

### 6.4.2 DSS签名算法的签名

对于消息m，首先随机选取整数$k,1\le k\le p-2$，然后计算$\begin{cases}r=g^k(mod\ p)(mod\ q)\\s=(h(m)+xr)k^{-1}(mod\ q)\end{cases}$

则m的签名为$(r,s)$，其中$h()$为hash函数SHA。

### 6.4.3 DSS签名算法的验证

接收方在收到信息m和签名$(r,s)$后，计算$\begin{cases}u_1=h(m)s^{-1}(mod\ q)\\u_2=rs^{-1}(mod\ q)\end{cases}$

验证$g^{u_1}y^{u_2}(mod\ p)(mod\ q)\overset{?}{=}r$。

如果等式成立，则$(r,s)$是消息m的有效签名，反之则是无效签名。

### 6.4.4 DSS签名算法的正确性

$$
\because&u_1+xu_2(mod\ q)=(h(m)+xr)s^{-1}(mod\ q)=k\\
\therefore&\begin{aligned}&g^{u_1}y^{u_2}(mod\ p)(mod\ q)\\=&g^{u_1+xu_2}(mod\ p)(mod\ q)\\=&g^k(mod\ p)(mod\ q)\\=&r\end{aligned}
$$



## 6.5 EI-Gamal类签名算法

### 6.5.1 基于离散对数问题的数字签名方案

EI-Gamal签名方案、DSS签名方案、Schnorr签名方案都是基于离散对数困难问题的签名方案。

密钥产生方式的共同点：都使用了离散对数方式来构造公私钥

签名方式类似性：如EI-Gamal数字签名：对于消息m，首先随机选取整数$k,1\le k\le p-2$，然后计算$\begin{cases}r=g^k(mod\ p)\\s=(h(m)-xr)k^{-1}(mod\ (p-1))\end{cases}$

则m的签名为$(r,s)$，其中$h()$为hash函数。若把k和x互换位置，依旧可以产生数字签名，这种类型的加密方式都属于EI-Gamal类签名算法

### 6.5.2 EI-Gamal签名算法的密钥生成

①：p和q是大素数，且$q\mid p-1$

②：随机选取q阶元g，$1\lt g\lt p-1$。$q,p,g$公开

③：随机选取整数$x,1\le x\le q-1$，计算$y=g^x(mod\ p)$

④：公钥为y，私钥为x

### 6.5.3 EI-Gamal签名算法的签名

对于消息m，计算签名如下：

①计算m的Hash值$h(m)$

②随机选取整数$k,1\le k\le q$，然后计算$r=g^k(mod\ p)$，从等式$ak=b+cx(mod\ q)$中计算出s。

其中方程的系数$a,b,c$有多总选择，取集合$\{a,b,c\}=\{r,s,h(m)\}$，则m的签名为$(r,s)$。

### 6.5.4 EI-Gamal签名算法的验证

接收方在收到信息m和签名$(r,s)$后，验证$g^by^c\overset{?}{\equiv}r^a(mod\ p)$，若成立则$(r,s)$是信息m的有效签名，反之则是无效签名。

参数$a,b,c$可能的选择：

| a               | b            | c      |
| --------------- | ------------ | ------ |
| $\pm r^{'}$     | $\pm s$      | $h(m)$ |
| $\pm r^{'}h(m)$ | $\pm s$      | 1      |
| $\pm r^{'}h(m)$ | $\pm h(m)s$  | 1      |
| $\pm h(m)r^{'}$ | $\pm r^{'}s$ | 1      |
| $\pm h(m)s$     | $\pm r^{'}s$ | 1      |

注：表中$r^{'}\equiv r(mod\ p)$

### 6.5.5 一些基于离散对数问题的签名方案

|      | 签名方程                       | 验证方程                              |
| ---- | ------------------------------ | ------------------------------------- |
| ①    | $r^{'}k\equiv s+h(m)x(mod\ q)$ | $r^{r^{'}}\equiv g^sy^{h(m)}(mod\ p)$ |
| ②    | $r^{'}k\equiv h(m)+sx(mod\ q)$ | $r^{r^{'}}\equiv g^{h(m)}y^s(mod\ p)$ |
| ③    | $sk\equiv r^{'}+h(m)x(mod\ q)$ | $r^s\equiv g^{r^{'}}y^{h(m)}(mod\ p)$ |
| ④    | $sk\equiv h(m)+r^{'}x(mod\ q)$ | $r^s\equiv g^{h(m)}y^{r^{'}}(mod\ p)$ |
| ⑤    | $mk\equiv s+r^{'}x(mod\ q)$    | $r^m\equiv g^sy^{r^{'}}(mod\ p)$      |
| ⑥    | $mk\equiv r^{'}+sx(mod\ q)$    | $r^m\equiv g^{r^{'}}y^smod\ p)$       |

## 6.6 特殊性质的签名算法

### 6.6.1 盲签名

**盲签名**：在发送者A和签名者B之间的双方协议，其基本思想是A发送给B一段信息，B对它签名并送回A。从这个签名，A能够计算B关于A预先所选信息m的签名。协议完成时，B既不知道信息m也不知道信息的签名。

盲签名的目的是防止B看到信息和签名，从而使B以后不能将所签信息和发送者A联系起来。

例如：发送者A（客户）不希望签名者B（银行）能够将一条先验消息m及其签名$S_B(m)$与协议的特定实例相联系。这个特性可能在电子现金应用中很重要，因为那里的信息也许表示A所花的金钱数额。当m和$S_B(m)$提交给B进行支付时，B无法推断原先接收签名的是谁。这就是允许A的匿名性，从而A的消费模式不能被监测。

盲签名协议需要下列组件：①签名者B的一种数字签名机制。用$S_B(x)$记B对x的签名。②**盲化函数**f和**去盲函数**g，满足$g(S_B(f(m)))=S_B(m)$，$f(m)$叫做**盲消息**。

**Chaum盲签名协议**：发送者A接收B关于盲消息的签名。A计算B关于A预先所选信息m的签名，$0\le m\le n-1$。B既没有消息m也没有m相关签名的知识。

设B的RSA公钥和私钥为$(n,e)$和d。k是A随机选择的秘密数，满足$0\le k\le n-1$且$gcd(n,k)=1$.

协议步骤：
①盲化：A计算$m^k=mk^e(mod\ n)$，把它发送给B。
②签名：B计算$s^k=(m^k)^d(mod\ n)$，把它发送给A。
③去盲：A计算$s=k^{-1}s^k(mod\ n)$，s就是B关于m的签名。

Chaum盲签名的正确性：显然s是m的签名（因为$s=m^d(mod\ n)$）。B既没有信息m也没有m相关签名s的知识。

### 6.6.2 不可否认签名

不可否认的数字签名由Chaum等在1989年提出。

不可否认签名没有签名者的合作，接收者无法验证签名。

例如：实体A（客户）希望范围被实体B（银行）控制的某个安全区域。比如该安全区域可能是存放保险箱的房间。在许可访问之前，B要求A签署一份时间和日期的文件。若A采用了不可否认签名，那么在验证过程中没有A的直接参与，B就无法向其他人证明A使用过安全区域中的设施。

又如：假定某大公司A制作了一个软件包。A对软件包签名并将它卖给实体B，而B决定将其拷贝再卖给第三方C，那么没有A的合作，C就无法验证该软件是否正版。当然，这种措施并不能阻止B用它自己的签名重新签署软件包，但因此B也就无法利用与A名气相关的市场利益。而且追踪B的欺诈行为也将很容易。

一个不可否认签名方案有三部分组成：
①签名算法：通过私钥产生消息m的签名
②验证协议：验证者在签名者合作的情况下对数字签名进行验证
③否认协议：数字签名是伪造的情况下，签名者能以很大概率证明其伪造性。

签名者可以声称一个签名是伪造的，在这种情况下，如果签名者拒绝参加验证，就可认可签名者有欺骗行为。如果签名者参加验证，由否认协议就可推断出签名的真伪。

否认协议需要做到：①B能使A相信一个不合法的签名是伪造的。②B以很小的概率使A相信一个合法签名是伪造的。

不可否认签名的一个不足之处是签名者有可能不在场或者拒绝合作，而导致签名无法被接收者验证。

解决方式：Chaum提出的“制定验证者签名”的概念，其中签名者制定某实体作为签名的验证者。这种机制有两点特性①一旦签名者不在场或者拒绝合作，验证者就有权利和接收者交互来检查签名。②验证者不能产生签名者的签名。

### 6.6.3 群签名

1991年，Chaum等提出群签名方案。

群签名：允许群里的某个成员以群的名义匿名地签发消息。满足下列三个条件：①只有群成员才能代表群进行签名②签名的接收者能验证签名是哪一个群的合法签名，但不能分辨具体的签名者③一旦出现争端，可借助群成员或一个可行的机构能识别出签名者。

例如：一个公司有极太计算机，每台都连在局域网上。公司的每个部门有其自己的打印机（也连在局域网上），并且只有本部门的人员才能允许使用其部门的打印机。因此，打印前必须确认用户在哪个部门工作。同时公司为了保密，不可约暴露用户的身份。然而，若有人滥用打印机，主管者必须能找出是谁在滥用打印机。

一个群签名方案由以下几个部分组成：
①建立（setup）：一个用以产生群公钥和私钥的多项式概率算法。
②加入（join）：一个用户和群管理员之间的交互式协议。执行该夏衣可以使用户成为群增员，群管理员得到群成员的秘密的成员管理密钥，并产生群成员的私钥和成员证书。
③签名（sign）：一个概率算法，当输入一个信息、一个群成员的私钥和一个群公钥后，输出对该信息的签名。
④验证（verify）：给定一个信息的签名和一个群公钥后，判断该签名相对于该群公钥是否有效。
⑤打开（open）：给定一个签名、群公钥和群私钥的条件下确定签名者的身份。

### 6.6.4 代理签名

一个代理签名方案由以下几个部分组成：
系统奖励：选定代理签名方案的系统参数，用户的密钥等。
签名权利的委托：原始签名将自己的签名权利委托给代理签名者。
代理签名的产生：代理签名这代表原始签名者产生代理签名。
代理签名的验证：验证人验证代理签名的有效性。

## 6.7 SM2数字签名算法

SM2是中国国家密码管理局颁布的中国商用公钥密码标准算法，它是一组椭圆曲线密码算法，其中包含加解密算法、数字签名算法。

2004年，由中国科学院软件研究所张振峰研究员主持研制完成

2010年12月，首次公开发布

2012年3月，成为中国商用密码标准（GM/T 0003-2012）

2016年8月，成为中国国家密码标准（GB/T 32918-2016）

2017年11月3日，在第55次ISO/IEC联合技术委员会信息安全技术分委员会（SC27）德国柏林会议上，含有我国SM2与SM9数字签名算法的ISO/IEC1488-3/AMD1《带附录的数字签名第3部分∶基于离散对数的机制-补篇1》获得一致通过，成为ISO/IEC国际标准，进入标准发布阶段。

具体内容略。

