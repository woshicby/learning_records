# 第三章 运输层

逻辑通信（logic communication）：运输层协议为运行在不同主机上才应用进程之间提供了逻辑通信，通过逻辑通信，这些主机仿佛直接相连一样

运输层协议在端系统之间实现而不是路由器。发送端把报文转换为报文段，传递给网络层，接收端网络层从数据报中提取运输层字段并交给运输层，运输层处理接受到的报文段并恢复为报文，给应用层使用

### 3.1.1 传输层和网络层的关系

传输层位于网络层智商，网络层提供主机之间的逻辑通信，传输层提供进程之间的逻辑通信

底层网络协议不能在网络层提供相应的服务器，传输层也能提供某些服务（如可靠性和保密性（使用加密））

### 3.1.2 因特网运输层概述

UDP（用户数据报协议）：无连接、不可靠

TCP（传输控制协议）：面向连接、可靠的

网络层协议叫IP（网际协议），服务模型为尽力而为交付服务（best-effort delivery service）是不可靠服务（unreliable service），另外每台主机至少有一个IP地址。

UDP和TCP的基本任务：把两个端系统IP的交付服务拓展为运行在端系统上的两个进程之间的交付服务，称为运输层的多路复用（multiplexing）和多路分解（demultiplexing）

提供完整性检查：在报文段首部中包括差错检查字段

UDP仅有的两种服务：进程到进程的数据交付、差错检查

TCP额外提供提供：可靠数据传输（reliable data transfer）：通过使用流量控制、序号、确认和定时器来确保正确的、按序地将数据从发送进程交付给接收进程、拥塞控制（congestion control）：通过调节发送端发送的流量速率来力求为每一个通过拥塞网络链路的连接平等地共享网络链路带宽（UDP流量是不可调节的）

## 3.2 多路复用和多路分解

多路分解（demultiplexing）：接收端，运输层检查运输层报文的字段，识别出接收套接字，进而将报文段定向到该套接字，将运输层报文段中的数据交付到正确的套接字。

多路复用（multiplexing）：源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息，从而生成报文段，然后将报文段传递到网络层的过程。

多路复用要求：①套接字有唯一标识符②每个报文段有特殊字段来指示该报文段说要交付到的套接字

特殊字段：源端口号字段（source port number field）、目的端口号字段（destination port number field）

端口号：16比特的数，大小在0-65535之间，0-1023是周知端口号（well-known port number），保留给周知应用层协议来使用（RFC 1700、RFC 3232）

### 3.2.1 无连接的多路复用和多路分解（UDP）

要实现一个“周知协议”的服务器端，那么要分配一个响应的周知端口号（客户端让运输层自动地（透明地）分配端口号）

一个UDP套接字由一个二元组全面标识（目的IP地址,目的端口号）

两个具有不同源IP地址或源端口号的TCP报文段被定向到同一个UDP套接字

源端口号用于作为“返回地址”的一部分。

### 3.2.2 面向连接的多路复用与多路分解（TCP）

TCP套接字由一个四元组（源IP地址,源端口号,目的IP地址,目的端口号）来标识。

两个具有不同源IP地址或源端口号的TCP报文段被定向到两个不同的TCP套接字

请求报文段中的四个值：①源端口号②源IP地址③目的端口号④目的IP地址（由这是个值创建一个TCP连接）

Ps.端口扫描器：用于确定哪个应用程序正在监听哪些端口。一般是顺序地扫描端口，寻找能够接受TCP连接的端口/对UDP报文段进行相应的UDP端口

### 3.2.3 Web服务器与TCP

只有一个进程，但是创建不同的套接字的时候会创建新的线程来进行服务（而不是多个进程）

连续HTTP：整条服务期间，客户与服务器之间经由同一个服务器套接字交换HTTP报文

非连续HTTP：每一对请求和相应都创建一个新的套接字随后关闭（影响服务器性能（操作系统技巧可以减轻这个问题的影响）

## 3.3 无连接运输：UDP

不提供不必要服务，所以最低提供一种复用/分用服务就可以了。

使用UDP时，在发送方和接收方的运输层实体之间没有握手，是无连接的

为什么宁愿在UDP上构建应用也不选择TCP上构建应用：①关于何时、发送什么样的数据的应用层控制更加精细（TCP的拥塞控制机制不太适合这种应用，如实时应用）②无需连接建立（连接的建立过程会导致时延，拖慢程序速度）③无连接状态（这样可以支持更多的活跃用户）④分组首部开销小（TCP首部有20字节开销，UDP只有8字节）

| 应用           | 应用层协议 | 下面的运输协议 | 选择的理由                                                   |
| -------------- | ---------- | -------------- | ------------------------------------------------------------ |
| 电子邮件       | SMTP       | TCP            | 需要TCP可靠数据传输                                          |
| 远程终端访问   | Telnet     | TCP            | 需要TCP可靠数据传输                                          |
| Web            | HTTP       | TCP            | 需要TCP可靠数据传输                                          |
| 文件传输       | FTP        | TCP            | 需要TCP可靠数据传输                                          |
| 远程文件服务器 | NFS        | 通常UDP        |                                                              |
| 流式多媒体     | 通常专用   | UDP/TCP        | 可以容忍少量的分组丢失（由于流量过大，产生了新的机制对UDP进行拥塞控制） |
| 因特网电话     | 通常专用   | UDP/TCP        | 可以容忍少量的分组丢失（由于流量过大，产生了新的机制对UDP进行拥塞控制） |
| 网络管理       | SNMP       | 通常UDP        | 通常必须在网络处于重压状态时运行                             |
| 路由选择协议   | RIP        | 通常UDP        | 更新被周期性地发送，丢包、过期的更新没有用                   |
| 名字转换       | DNS        | 通常UDP        | 避免TCP的连接创建时延                                        |

### 3.3.1 UDP报文段结构（RFC 768）

首部：源端口号（2字节）目的端口号（2字节）长度（2字节，整个报文段的字节数）检验和（2字节）

### 3.3.2 UDP检验和

提供差错检测功能，用于确定UDP报文段从源到目的地的过程中，其中的比特是否发生了改变

UDP检验和：对报文段中所有16比特字的和（有溢出则进行回卷）进行反码运算，结果放在UDP检验和

UDP检验和的计算方法是：
1.按每16位求和得出一个32位的数；
2.如果这个32位的数，高16位不为0，则高16位加低16位再得到一个32位的数；
3.重复第2步直到高16位为0，将低16位取反，得到校验和。

验证方法：把全部的16比特字加在一起，结果为全1则没有差错

为什么UDP首先提供了检验和：虽然许多链路层协议都提供了差错检测，但是不能保证源和目的之间的所有链路都提供了差错检测，即使链路都提供了差错检测，在其中某个路由器的内存中时，也可能产生比特差错，要在端到端传输服务中提供差错检测，就必须在端到端的运输层提供差错检测。（表现了端到端原则）

端到端原则（end-end principle）：因为某种原则必须基于端到端实现，那么与再较高级别提供这些功能的代价相比，在较低级别上设置的功能可能是冗余或几乎没有价值的。

UDP提供差错检测，但它对于差错恢复无能为力，只能丢弃受损的报文段或者把受损的报文段交给应用程序并给出警告。

## 3.4 可靠数据传输原理

可靠数据传输（reliable data transfer protocol）：为上层实体提供一个可靠的信道，借助可靠的信道，传输数据比特不会受到损坏或丢失，所有数据都是按照发送顺序进行交付。

单向数据传输（unidirectional data transfer）：数据传输是从发送端到接收端的

双向数据传输（bidirectional data transfer）：全双工数据传输

### 3.4.1 构建可靠数据传输协议（停等协议rdt1.0-3.0）

#### rdt1.0：经完全可靠信道的可靠数据传输：（发送方1个，接收方1个状态）

发送端：接受较高层次的数据，产生包含该数据的分组，把分组发送到信道中。

接收端：接收到分组，从分组中取出数据，把数据传给较高层。

由于有完全可靠的信道，接收端不需要提供任何反馈信息给发送方，接收方接收数据的速率也和发送方发送数据的速度一样快（完全理想情况）

有限状态机（Finite-State Machine，FSM）

#### rdt2.0：经具有比特差错信道（不会丢包）的可靠数据传输（发送方2个，接收方1个状态）

肯定确认（positive acknowledge）：对数据的成功接收进行确认

否定确认（negative acknowledge）：对数据没能成功接收进行反馈

自动重传请求（Automatic Repeat Request，ARQ）：基于肯定确认和否定确认来确定哪些内容被正确接收，哪些内容接收有误而需要重复发送的重传机制

ARQ协议的三功能：差错检测（如UDP的校验和）、接收方反馈、重传

rdt2.0的致命缺陷：ACK或NAK分组受损的可能性

可能性一：添加对确认分组进行确认的分组（子子孙孙无穷尽也）

可能性二：添加足够的检验和比特，使得不仅可以检验差错，还能恢复差错（如果不会丢失分组的话，这就可以了）

可能性三：收到不清楚的ACK或NAK分组，就重传当前分组（在发送方到接收方的信道中引入了冗余分组（duplicate packet），而且接收方不知道这是一个重传还是一个新的分组）

对可能性三，只要对分组进行编号就好了，这就产生了rdt2.1。

#### rdt2.1：经具有比特差错信道（不会丢包）的添加了编号的可靠数据传输（发送方4个，接收方2个状态）

对分组进行0、1的编号，有两种否定确认（NAK0、NAK1）这样就能知道没有正确收到的是0号还是1号分组

#### rdt2.2：经具有比特差错信道（不会丢包）的无否定确认的的可靠信道传输协议（发送方2个，接收方2个状态）

把肯定确认带上编号（ACK0、ACK1），如果没有正确收到下一个，就对前一个分组再发一次肯定确认，这样就可以用两个一样的肯定确认来发现有受损，从而重传了。

#### rdt3.0：经具有比特差错的丢包信道的可靠数据传输（发送方4个，接收方2个状态）

要关注的问题：怎样检测丢包、发生丢包后应该做些什么（rdt2.2已经可以解决，主要问题还是怎么检测丢包）

一个比较简单的方法：停等

让发送方负责检测和恢复丢包工作：不管是数据分组丢失还是ACK发生丢失，发送方都收不到应该受到的响应，经过足够长的时间之后就可以确定分组已经丢失，重传就好了。

至少需要等待的市场：一个RTT加上接收方处理一个分组需要的时间

基于时间的重传机制：要一个倒计数定时器（countdown timer），在一个给定的时间量过期后，可中断发送方。

发送方需要做到：①每次发送一个分组时（包括第一次分组和重传分组），就启动一个定时器②响应定时器中断（用合适的动作）③终止定时器

rdt3.0也称为比特交替协议（alternating-bit protocol）

### 3.4.2 流水线可靠传输协议

停等协议的缺点：信道利用率（utilization）低，时延大，性能糟糕

流水线（pipelining）：允许发送端发送多个分组而无需等待确认

使用流水线技术产生的新问题：①必须增加序号范围（每个输送中的分组必须有一个唯一的序号，也有多个在输送中未确认的报文）②协议的发送方和接收方也要缓存多个分组③发生差错如何恢复（两种基本方法：回退N步（Go-Back-N，GBN）、选择重传（Selective Repeat，SR））

### 3.4.3  回退N步（GBN）/滑动窗口协议（sliding-window protocol）
N窗口长度（window size）：流水线中未确认分组的最大允许数

基序号（base）：最早的未确认分组的序号

下一个序号（nextseqnum）：最小的未使用序号

0到base-1：已经发送且被确认的分组；base到nextseqnum-1：最近发送且未被确认的分组；nextseqnum到base+N-1：要被立即发送的分组

拓展FSM：在FSM中增加变量、对变量的操作、与变量有关的条件动作

GBN发送方要做的事：响应上层的调用（检查窗口是否已满，未满：发送，满：报告上层）、响应收到一个ACK（采用累积确认（cumulative acknowledgment）方式，把ACK序号及其以前的都标记为收到）、响应超时事件（重传所有已发送但未被确认的分组）、维护窗口的上下编讲以及nextseqnum在该窗口中的位置

GBN接收方：丢弃所有失序分组（接收缓存简单，不需要缓存任何失序分组）、维护下一个需要接受的分组的序号

基于事件的编程（event-based programming）：这些过程要么被协议栈中的其他过程调用，要么作为一次中断的结果

发送方事件包括：①来自上层实体的调用②定时器中断③报文到达时来自下层的调用

### 3.4.4 选择重传（SR）

GBN的问题：性能不行（尤其是窗口长度和时延带宽积都很大的时候）、单个分组的差错就能引起GBN重传大量分组

选择重传（SR）协议：让发送方仅重传那些它怀疑在接收方出错的分组，从而避免不必要的重传

SR发送方的动作：①从上层收到数据：检查下一个可用于该分组的序号，在窗口内则打包发送，在窗口外则缓存或者报告上层（和GBN一样）②超时：每个分组要拥有一个单独的逻辑计时器，因为超时发生后只能发送一个分组（可以用单个硬件计时器来模拟多个逻辑计时器）③收到ACK：若分组序号在窗口内就标记为已接收，如果ACK的是基序号，滑动窗口并发送窗口内的未发送分组。

SR接收方的动作：失序的分组将被缓存，直到所有它之前分组都被收到为止，然后一起交付给上层。①序号在[rev_base,rev_base+N-1]内的分组被正确接收：回复一个对应的ACK，如果没收到过，就缓存该分组，如果序号等于基序号，交付这个分组和之后连续的缓存过的分组并滑动窗口②序号在[rev_base-N,rev_base-1]内的分组被正确收到，则返回一个对应的ACK③其他情况直接忽略

Ps.已经收到过的序号小于当前窗口基序号的分组，接收方会重新确认（为了让发送方知道已经正确收到，从而滑动窗口，否则会导致窗口缺乏同步）

窗口缺乏同步会产生的后果：同一个序号被两个不同分组采用，无法确认是新分组还是重传。（对于SR协议而言，窗口长度必须小于或等于序号空间的一般，否则会出现这种情况）

| 机制| 用途和说明|
| ---- | ---|
| 检验和| 用于检测在一个传输分组中的比特错误。                         |
| 定时器| 用于超时/重传一个分组，因为它或者它的ACK可能在信道中丢失了。由于一个分组延时但未丢失（过早超时），或单一个分组已被接收方收到但从接收方到发送方的ACK丢失时，可能产生超时事件，所以接收方可能会收到一个分组的多个冗余副本。 |
| 序号| 用于为从发送方流向接收方的数据分组按顺序编号。所接收分组的序号间的空隙可使接收方检测出丢失的分组。具有相同序号的分组可使接收方检测出一个分组的冗余副本。 |
| 确认| 接收方用于告诉发送方一个分组或一组分组已被正确地接收到了。确认报文通常携带着被确认分组的序号。确认可以是逐个的或累积的，这取决于协议。 |
| 否定确认| 接收方用于告诉发送方一个分组或一组分组未被正确地接收。否定确认报文通常携带着未被正确接收的分组的序号。 |
| 窗口、流水线 | 发送方也许被限制仅发送那些序号落在一个指定范围内的分组。通过允许一次发送多个分组但未被确认，发送方的利用率可在停等操作的基础上得到增加。我们很快将会看到，窗口长度可根据接收方接收和缓存报文的能力、网络中的拥塞程度或两者的情况来进行设置。 |

### 3.4.5 一个遗留问题：分组在发送方和接收方之间如果被重新排序怎么办

重新排序其实相当于信道在缓存信息，并且在将来任意时刻自然地释放出这些分组。（由于序号可以重复使用，这还挺要命）

对应方法①确保一个序号x不再使用，知道发送方确信任何先前发送的序号为x的分组都不在网络中为止。一般通过假定一个分组在网络中的“存活”时间不会超过某个固定最大时间来实现。在高速网络的TCP拓展中，这个时间大约3分钟

## 3.5 面向连接的传输：TCP

TCP是面向连接的（connection-oriented）：一个应用程序开始向另一个应用进程发送数据之前，必须先“握手”（相互发送某些预备报文段以建立确保数据传输的参数），双方都要初始化与TCP连接相关的许多TCP状态变量。TCP的连接对于中间的链路完全视而不见

TCP/IP（Transmission Control Protocol/Internet Protocol）传输控制协议/网际协议

TCP提供全双工服务（full-duplex service）：如果一台主机上的进程A与进程B存在一条TCP连接，那么应用层数据就可以在进程B流向进程A的同时也从进程A流向进程B。

TCP是点对点（point-to-point）的：在单个发送方与单个接收方之间的连接。

多播（在一次发送操作中从一个发送方将数据传输给多个发送方）对TCP是不可能的

三次握手（three-way handshake）：①客户发送一个特殊的TCP报文段②服务器用另一个特殊的TCP报文段来响应③客户用第三个特殊报文段来响应（这个可以承载有效载荷）

发送缓存（send buffer）：在TCP三次握手初期设置的缓存之一，储存待发送的数据

接收缓存：在TCP三次握手初期设置的缓存之一，储存接收到的数据

能主存的数据数量受限于最大报文段长度（Maximum Segment Size，MSS）

MSS根据最初确定的由本地发送主机发送的最大链路层帧长度（最大传输单元（Maximum Transmission Unit，MTU））来设置。

要保证一个TCP报文段（封装在IP数据报中）加上TCP/IP首部长度（通常40字节）适合单个数据链路帧（而以太网和PPP的链路层协议都有1500字节的MTU，所以MSS常常为1460字节）

MTU：能从源到目的地的所有链路上发送的最大链路层帧

MSS：在报文段里应用层数据的最大长度（不包括TCP/IP首部）

TCP报文段（TCP segment）：在每块客户数据上配上一个TCP首部，就形成了TCP报文段。

### 3.5.2 TCP报文段结构

首部：16bit源端口号、16bit目的端口号、

32bit序号字段（sequence number field）、32bit确认号字段（acknowledgment number field）——用于实现可靠数据传输

4bit首部长度字段（header length field）、4bit保留不用、6bit标志字段（flag field）：URG（紧急数据）、ACK（确认）、PSH（直通，立即交付）、RST、SYN（建立连接）、FIN（中断连接）

16bit接收窗口字段（receive window field）——用于流量控制

16bit校验和字段（checksum field）、16bit紧急数据指针：配合URG标志使用，指出紧急数据的最后一个字节（当紧急数据存在的时候，TCP会通知上层实体）

可变长的选项字段（options field）

#### 3.5.2.1 序号和确认号

TCP把数据看成一个无结构的有序的字节流，所以序号是对应与字节流的

一个报文段的序号（sequence number for a segment）：该报文段首字节的字节流编号

确认好：主机期望从对方收到的下一个字节的序号

TCP累积确认（cumulative acknowledgment）：TCP只确认该流中到第一个丢失字节为止的字节

报文段失序的解决方法：TCP没有明确指定，一般使用保留失序的直接，并等待缺少的直接来填补该间隔。

TCP的双方都可以随机地选择初始序号，可以减少把仍在网络中存在的两台主机之间先前已终止的连接的报文段当作是后来的新连接所产生的有效报文段的可能性。

确认被捎带（piggybacked）在数据报文段中：对数据的确认装载在一个承载数据的报文段中。

### 3.5.3 往返时间的估计与超时（RFC 6298）

超时重传机制需要设置超时间隔长度，这必须大于RTT

#### 3.5.3.1 估计往返时间（RFC6298）

仅在某些时刻进行SampleRTT的测量（而不是每个报文段都测量），Ps.不为已被重传的报文段计算SampleRTT

然后进行更新：$$EstimatedRTT=(1-\alpha)\times EstimatedRTT+\alpha\times SampleRTT$$

RFC6298中给出的α参考值为0.125，这种方法称为指数加权移动平均（Exponential Weighted Moving Average，EWMA）

RFC6298中给出了RTT偏差DevRTT，用于估算SampleRTT一般会偏离EstimatedRTT的程度:$$DevRTT=(1-\beta)\cdot DevRTT+|SampleRTT-EstimatedRTT|(\beta的推荐值为0.25)$$

#### 3.5.3.2 设置和管理重传超时间隔

①超时间隔应该大于EstimatedRTT②不能大太多，否则不能及时重传③SampleRTT波动大时余量应该打，SampleRTT波动小时余量应该小

综上所述$$TimeoutInterval=EstimatedRTT+4\cdot DevRTT$$

推荐的初始TimeoutInterval值为1秒，出现超时后TimeoutInterval值将被加倍，以免即将被确认的候机宝文段过早出现超时，而一旦报文段收到并更新EstimatedRTT后，TimeoutInterval就又使用上述公式计算了

Ps.有些版本的TCP还有一个隐式NAK机制（收到对一个特定报文段的三个冗余ACK就作为对后面一个报文段的一个隐式NAK，触发重传），TCP也使用流水线，窗口大小由TCP的流量控制和拥塞控制机制来确认

### 3.5.4 可靠数据传输

TCP的可靠数据传输服务（reliable data transfer service）：保证一个进程从其接收缓存中读出的数据流是无损坏、无间隔、非冗余、按序的数据流，与发送方发送出的数据流完全相同。

仅使用一个重传计时器。

简化版TCP发送方关于重传的事件：①从上层应用程序接收数据②定时器超时③收到ACK

①从上层应用程序接收数据：把数据封装在报文段中，并把报文段交给IP。如果定时器没有被某些其他报文段使用的话，启动该定时器，设定的过期间隔为TimeoutInterval

②超时：重传引起超时的报文段，然后重启定时器

③收到ACK：把ACK的值y和它的变量SendBase进行比较，进行累计确认，y>SendBase，则更新SendBase（滑动窗口）

#### 3.5.4.2 超时间隔加倍（一个形式受限的拥塞控制方式）

进行如下改动：

超时→重传有最小序号的还没被确认的报文段，把下一次的超时间隔设为先前值的两倍（而不是TimeoutInterval）

如果一直发生超时，这时间就会一直×2

该操作提供了一个形式受限的拥塞控制：因为定时器过期很可能是由于网络拥塞而引起的，所以把重传的时间间隔加长，不会进一步加重拥塞

#### 3.5.4.3 快速重传：在该报文段的定时器过期之前重传丢失的报文段

收到冗余ACK（duplicate ACK）的原因：接收方受到了比期望序号的的失序报文段

由于采用流水线模式，所以一旦有一个报文段丢失，就很可能引起一系列冗余ACK，所以产生了快速重传

快速重传（fast retransmit）：如果发送方收到连续3个期待序号相同的冗余ACK，则认为那个报文段已经丢失，重传那个报文段（而不是等定时器过期）

#### 3.5.4.4 TCP是GBN还是SR

TCP是一种GBN和SR的混合体：

①TCP的确认是累积式的，正确接收但失序的报文段不会被接收方逐个确认，所以发送方只要保持SendBase（以发送未确认的最小序号）和NextSeqNum（下一个要发送的序号）就可以了。但TCP常常会吧失序的报文段缓存起来，而不是等着重新再发，TCP不会在确认n超时前重传n+1号报文段

②TCP也可以有选择得确认失序报文段，而不是累积地确认最后一个正确接收的有序报文段，这就很像SR协议了

### 3.5.5 流量控制

流量控制服务（flow-control service）：消除发送方使得接收方缓存溢出的可能性，是一个速度匹配服务，使发送方的发送效率和接收方应用程序的读取速度相匹配。

具体方法：发送方维护一个接收窗口（receive window）的变量。接收窗口用于告诉发送方接收方还有多少可用的缓存空间

LastByteRead：接收方的应用程序已经从缓存读出的数据流中最后一个字节的编号

LastByteRevd：从网络中已到达的并且已放入接收缓存中的数据流的最后一个字节的编号

则LastByteRevd-LastByteRead≤RevBuffer

接收窗口rwnd=RevBuffer-（LastByteRevd-LastByteRead）

若rwnd=0时，若接收方没有新的通知，则发送方被堵塞，所以发送方会继续发送只有一个字节数据的报文段，从而获取ACK报文，直到rwnd≠0

### 3.5.6 TCP连接管理

三次握手和四次挥手来建立和拆除一条TCP连接

三次握手（three-way handshake）：

①客户端向服务器端发送SYN报文段，请求连接：SYN=1，seq=client_isn（随机选择的初始序号）

②服务器为该TCP连接分配TCP缓存和变量，并回复SYNACK报文段，允许连接：SYN=1，ack=client_isn+1，seq=server_isn（另一个随机选择的初始序号）

③客户端为该TCP连接分配TCP缓存和变量，并回复：SYN=0，seq=client_isn+1，ack=server_isn+1（可以负载要发往服务器的数据）

四次挥手：

①一方发送FIN报文段

②另一方发送ACK报文段

③另一方发送FIN报文段

④一方发送ACK报文段

TCP状态：CLOSED（关闭）、SYN_SENT（等待确认）、ESTABLISHED（已建立）、FIN_WAIT_1（等待关闭1）、FIN_WAIT_2（等待关闭2）、TIME_WAIT（等待关闭）

SYN洪泛攻击：攻击者发送大量的TCP SYN报文段，而不完成第三次握手的步骤，骗取服务器的资源，导致服务器崩溃。

对SYN洪泛攻击的防御手段：SYN cookie（RFC4987）：收到一个SYN报文段时，不生成半开的连接而是生成一个初始TCP序列号，该序列号是SYN报文段的源和目的地址与端口号加上hash函数得到的hash值，然后发送具有这个特殊序列号的SYNACK分组。如果客户是合法的，会返回ACK报文段（三次握手），服务器收到ACK之后，验证这个ACK是否与前面发送的一些SYN对应（用cookie完成，因为合法的ACK中，ack=服务器发出的seq+1，只要验证hash结果是否等于ack-1即可，验证成功就有开启一个全开的连接）

主机在没有监听的端口收到一个TCP SYN分组→向源发送一个RST标志位=1的特殊重置报文段

主机在没有监听的端口收到一个UDP分组→发送一个特殊的ICMP数据报

用TCP SYN进行端口扫描的结果：①收到TCP SYNACK报文段→有一个应用程序在实用这TCP端口②收到TCP RST报文段→SYN报文到达了目的主机③什么都没收到→被中间的防火墙所阻挡

## 3.6 拥塞控制

主要讨论异步传递方式（ATM）的网络中可用比特率（ABR）服务中的拥塞控制

### 3.6.1 拥塞原因和代价

情况1：两个发送方和一个有无限大缓存的路由器：链路容量为R，则无论发送速率多高，最多只能看到每连接R/2的吞吐量，且发送速率接近R/2时平均时延会打打增加，超过R/2时，时延会变成无穷大。

每连接的吞吐量（per-connection throughput）：接收方每秒接收的字节数

情况2：路由器的缓存变成有限的：若不发生丢包，供给载荷不能超过R/2；若仅在确认一个分组已经丢失了才重传，接收载荷只有R/3；若发送方提前发生超时并重传在队列中已被推迟但还未丢失的分组则接收载荷接近R/4。

网络拥塞的代价：发送方必须执行重传以补偿因为缓存溢出而丢失的分组、发送方不必要的重传会引起路由器利用其链路带宽转发比必要的分组副本

供给载荷（offer load）：发送方向网络中发送报文段（包括初始数据和重传数据）的数率（字节/s）

情况3：不同的连接有共用的路由器：连接的流量随着其他连接供给载荷的提高，会被占用导致非共用的上游路由器在做无用功。

网络拥塞的代价：一个分组沿一条路径被丢弃掉时，每个上游路由器用于转发该分组到丢弃到该分组而使用的传输容量被浪费了

### 3.6.2 拥塞控制方法

端到端拥塞控制：网络层没有为运输层拥塞控制提供支持，靠丢失和时延来控制。改变窗口大小和往返时延值

网络辅助的拥塞控制：网络层构件为发送方提供显式反馈信息，如用一个比特来指示拥塞情况（IBM SNA、DEC DECnet）、发给发送方一个阻塞分组（choke packet）

### 3.6.3 网络辅助的拥塞控制例子：ATM ABR拥塞控制

ATM用面向虚电路的方法来处理分组交换：路径上的每台交换机都维护源到目的地的虚电路状态

ABR弹性数据传输服务：带宽足够时充分利用空闲的可用带宽，网络拥塞是把传输速率抑制为某些预先确定的最小传输速率

控制方式：在数据信元之间夹杂着一些资源管理信元（Resource-Management cell），资源管理信元用于在主机和交换机之间传递与拥塞有关的信息。

RM信元到达目的地后会调转方向向发送方发送，交换机也能产生RM信元给发送方，发送方搜集回送的RM信源调整发送速率

ABR的信令信息：

①EFCI比特：每个数据信元都包含1比特的显式转发拥塞指示（Explicit Forward Congestion Indication，EFCI）比特。用于指示网络是否拥塞，目的主机检查EFCI如果多数EFCI都是1，就将RM信元的CI比特设置为1并回传。

②CI、NI比特：每个RM信元都包含拥塞指示（Congestion Indication，CI）比特、无增长（No Increase，NI）比特，交换机在轻微堵塞的时候把路过的RM信元的NI比特置为1，严重堵塞的时候把CI比特置为1，目的主机也可能自己把CI置为1。

③ER：RM信元包含一个2字节的显式速率（Explicit Rate，ER）字段，交换机在堵塞的时候会吧这个字段设置为路径中所有交换机的最小可支持速率

源主机根据CI、NI、ER来调整其发送信元的速率，起到拥塞控制的作用

## 3.7 TCP拥塞控制

TCP使用端到端拥塞控制，首先LastByteSent-LastByteAcked≤min｛cwnd,rwnd｝

出现丢包事件（出现超时或收到3个冗余ACK）→发送方知道路径出现拥塞

TCP的自计时（self-clocking）：ACK到达得快，则拥塞窗口增大的快，反之亦然

TCP确定发送速度的原则：①丢失的报文段意味着拥塞，因此发生丢失时应当降低TCP发送方的速率②一个ACK报文段指示该网络正在对报文段进行交付，可以增加发送速率③带宽检测：ACK和丢包事件充当隐式信号，每个TCP发送方根据异步于发送方的本地信息而行动

TCP拥塞控制算法（TCP congestion control algorithm）（RFC5681）：慢启动、拥塞避免、快速恢复

慢启动和拥塞避免是必须的，快速恢复并非必须的。

### 3.7.1 慢启动

慢启动（slow-start）状态：cwnd的值以1个MSS开始，获得一个ACK就×2，开始增长较慢，之后越来越快（指数增长）。

结束慢启动：方式①发生丢包，则cwnd=1，ssthresh（慢启动阈值）设置为cwnd/2，则下一次cwnd慢启动到ssthresh时转为每次+1（拥塞避免模式）

方式②：收到3个冗余ACK，执行快速重传并进入快速恢复状态

Ps.TCP的慢启动导致一开始时延很大（特别是端系统远离数据中心的时候），解决方法：①部署邻近用户的前端服务器②在该前端服务器利用TCP分岔（TCP splitting）来分裂TCP链接

TCP分岔：用一个前端服务器和用户们保留正常的TCP连接（RTT较小，对时延影响不大），前端服务器和数据中心（RTT大）之间维持一个窗口很大的TCP连接，这个连接中可以处理大量用户请求，不会导致每个用户被大的RTT影响到。

### 3.7.2 拥塞避免

收到一个新的ACK，cwnd就+1，直到发生丢包/超时事件，重置cwnd为1，更新ssthresh=cwnd/2，开始慢启动

### 3.7.3 快速恢复

TCP Tahoe就没有快速回复，一丢包就cwnd=1；TCP Reno加入了快速恢复。

快读回复：发生丢包时，直接把cwnd设置为新的ssthresh，执行拥塞避免，而不是回到1开始慢启动。

### 3.7.4 TCP拥塞控制结论

TCP的拥塞控制体现出了加性增，乘性减（Additive-Increase，Multiplicative-Decrease，AIMD）的拥塞控制。

TCP Vegas：试图维持较好吞吐量而不发生拥塞①在分组丢失发生前在源和目的之间检测路由器的拥塞②发现快发生分组丢失时，线性降低发送速率（通过RTT来预测）

TCP CUBIC：为高带宽应用而开发，是Linux系统的默认TCP版本（Linux系统可以配置使用哪个版本的TCP）

### 3.7.5 TCP的吞吐量

由于TCP的窗口呈锯齿状变化，则平均吞吐量可能为多少？

忽略慢启动阶段（因为这个阶段很短），窗口长度为w字节时，发送速率大概为w/RTT，发生丢包时的窗口为W，因为W和RTT几乎不变，所以传输速率在$$W/(2\times RTT)$$和$$W/RTT$$之间波动，

$一条连接的平均吞吐量=\frac{0.75\times W}{RTT}$

考虑丢包率$L=\frac{1}{\frac{3}{8}W^2+\frac{3}{4}W}$、往返时间RTT、最大报文段MSS的话：

$一条连接的平均吞吐量=\frac{1.22\times MSS}{RTT\sqrt{L}}$

### 3.7.6 公平性

TCP趋向于在竞争的多条TCP连接之间提供对一段瓶颈链路带宽的平等分享，有些应用使用多条并行的TCP连接，就会分得比只使用一条或者少量TCP连接的应用多分到一些流量。

UDP源可能压制TCP流量，因为TCP在面临拥塞增加时会降低其传输速率，而UDP不会

## 3.8 小结（顺便介绍其他的传输层协议）

数据报拥塞控制协议（Datagram Congestion Control Protocol，DCCP）[RFC 4340]：提供了一种低开销、面向报文、类似于UDP的不可靠服务，但是有可供应用程序选择的拥塞控制形式，与TCP兼容。

流控制传输协议（Stream Control Transmission Protocol，SCTP）[RFC 4960、3286]：可靠的，面向报文的协议，允许几个不同的应用层的“流”复用到单个SCTP连接上，允许数据经两条出路径传输，还具有失序数据的选项交付和其他特色。

TCP友好速率控制（TCP-Friendly Rate Control，TFRC）[RFC 5348]：是一种拥塞控制协议，可以用于DCCP或其他传输协议。目标是平滑TCP拥塞控制的锯齿状行为，维护一个长期的发送速率，这个速率“合理地”接近TCP的速率，但是变化更加平滑。使用一个方程来根据丢包率估算合理的吞吐量，然后加以调整。
